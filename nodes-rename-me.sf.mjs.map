{"version":3,"names":["window","templates","_$_","sf","dom","$","__tmplt","_sf_internal","body_map","_replace","h","html","this","path","remove","reinitViews","append","prepend","Blackprint","loadScope","url","Context","getContext","console","PlaceHolder","IFace","MyTemplate","constructor","super","node","keepMe","text","css","width","textAlign","log","init","$el","IInput","IOutput","Input","Output","ref","My","port","target","cable","on","activate","callback","myLongTask","success","setTimeout","hotReload","hotReloading","hotReloadedHTML","hotReloaded"],"sources":["src/_init.sf","src/FeatureName/Template.sf"],"sourcesContent":[".js will run first before .sf\n\n## js-global\n// This script will run first, and then the other .sf files\n// depends on blackprint.config.js configuration\n\n// Prepare stuff when the page is loading\n// maybe like loading our dependencies for the nodes\n\n/* If you have loaded any dependency from ./init.js can also wait from here\n * Warning: When using this, you must modify wrapped:'mjs' to wrapped:'async-mjs'\n * on blackprint.config.js, to avoid circular waiting (because this module also waiting)\n *\n * Info: imports.task() == sf.loader.task;\n */\n// await imports.task();\n\n\n// Because .js and .sf is separated\n// we also need to call LoadScope just like _init.js\nlet Blackprint = window.Blackprint.loadScope({\n\t// You can find the URL on Blackprint menu -> Modules\n\t// This will also be exported to JSON if this module's nodes is being used\n\turl: import.meta.url,\n});\n\n// Use sQuery\nlet $ = sf.$;\n\n// Global shared context (wait it to avoid race condition)\nlet Context = await Blackprint.getContext('LibraryName');\n\n// Context.EventSlot => shared from \"_init.js\"","This file is just reference, you can remove unnecessary lines.\n\n## html\n<div class=\"node your-class\" style=\"transform: translate({{ x }}px, {{ y }}px)\">\n  <sf-template path=\"Blackprint/nodes/template/routes.sf\"></sf-template>\n  <sf-template path=\"Blackprint/nodes/template/header.sf\"></sf-template>\n\n  <div class=\"content\">\n    <div class=\"design-me\">You can design me with CSS</div>\n\n    <div class=\"left-port\">\n      <sf-template path=\"Blackprint/nodes/template/input-port.sf\"></sf-template>\n    </div>\n\n    <div class=\"right-port\">\n      <sf-template path=\"Blackprint/nodes/template/output-port.sf\"></sf-template>\n    </div>\n  </div>\n\n  <sf-template path=\"Blackprint/nodes/template/other.sf\"></sf-template>\n</div>\n\n## scss-global\n// BPIC/LibraryName is prefix from blackprint.config.js\n\n// Element name based on html path, BPIC/LibraryName/FeatureName/Template.sf\nbpic-libraryname-featurename-template {\n  /* Write your scoped SCSS here */\n  .design-me{\n    color: yellow;\n    width: 100%;\n    height: 15px;\n    text-align: center;\n    padding: 5px;\n  }\n}\n\n## js-global\n// You can also write JavaScript here\n// All script from .sf will be combined and wrapped depends on the configuration\nconsole.log(\"Hello from Template.sf\");\n\n// Get the reference from Template.js\nlet PlaceHolder = Context.PlaceHolder;\n\n// .registerInterface is case sensitive\n// Please also use capitalization on the file name\n\n\n// For Sketch Interface, let ScarletsFrame handle this (HotReload available here)\n// - first parameter is HTML file path\n// - second parameter is optional if using different settings\n// - third parameter can be placed on second parameter\nBlackprint.Sketch.registerInterface('BPIC/LibraryName/FeatureName/Template',\nclass IMyTemplate extends Context.IFace.MyTemplate {\n  // this == iface\n\n  constructor(node){\n    super(node); // 'node' object from .registerNode\n\n    this.keepMe = $('<div>');\n    this.keepMe.text(\"Hello world!\");\n    this.keepMe.css({\n      width: '100%',\n      textAlign: 'center'\n    });\n\n    // Any property on 'iface' can be binded with the HTML\n    this.log = '123'; // <div attr=\"{{ log }}\">{{ log }}</div>\n  }\n\n  // Will run once the node element was attached to DOM tree\n  init(){\n    // When ScarletsFrame initialized this HTML element\n\n    // Run everytime ScarletsFrame hot reload current scope\n    this.$el('.content').prepend(this.keepMe);\n    var Node = this.node; // 'node' object from .registerNode\n\n    // === Shortcut to get/set node's port value ===\n    var My = this; // Lazy Shortcut :3\n    // My.init = function(){...}\n\n    // This is just a shortcut of \"Node.input\" and \"Node.output\"\n    // initialized from Template.js\n    const {\n      IInput, IOutput, // Port interface\n      Input, Output, // Port value\n    } = My.ref; // My.ref === this.ref\n\n    // Update the port value\n    Output.PortName2 = 123; // This will also trigger 'value' event to connected input ports\n    // Output.PortName2 === My.node.output.PortName2\n\n    // Node event listener can only be registered after node init\n    My.on('cable.connect', Context.EventSlot, function({ port, target, cable }){});\n\n    // Event listener can be registered for IInput, IOutput\n    IInput.PortName1.on('value', Context.EventSlot, function(ev){\n        console.log(\"PortName1:\", ev);\n\n\t      // If have changed output port's value inside this listener\n        // you may also need to trigger route out `iface.node.routes.routeOut();`\n      })\n\n      // When the port connected with other port\n      .on('connect', Context.EventSlot, function({ port, target, cable }){})\n\n      // When the port disconnected with other port\n      .on('disconnect', Context.EventSlot, function({ port, target, cable }){});\n\n    function myLongTask(callback){\n      setTimeout(()=> callback(true), 1000);\n    }\n\n    // When this port are trying to connect with other node\n    IOutput.PortName2.on('connecting', Context.EventSlot, function({ port, target, activate }){\n      myLongTask(function(success){\n        if(success) activate(true); // Cable will be activated\n        else activate(false); // Cable will be destroyed\n      });\n\n      // Empty = is like we're not giving the answer now\n      activate() // Mark as async\n\n      // Or destroy it now\n      // activate(false)\n    })\n\n    // ...\n  }\n\n  // Below are optional life cycle, only for Blackprint.Sketch.Interface\n\n  // This must use ScarletsFrame Development mode\n  // Hot reload feature also must be activated\n  hotReload(){\n    console.log(\"Going to hot reload this object\", this);\n    this.hotReloading === true; // this will be true\n  }\n\n  hotReloadedHTML(){\n    console.log(\"Was HTML changed/reloaded\", this);\n  }\n\n  hotReloaded(){\n    console.log(\"Hot reload active\", this);\n\n    // Let's call init again\n    this.init();\n  }\n\n  /*\n  destroy(){\n    this.init();\n  }\n\n  initClone(){\n    this.init();\n  }\n\n  destroyClone(){\n    this.init();\n  }\n  */\n});"],"mappings":"8HAEAA,EAAAC,YAAAD,EAAAC,UAAA,QAAAC,EAAAC,GAAAC,KAAAD,GAAAE,EAAAC,EAAAN,EAAAC,UAAAD,EAAAO,aAAAP,EAAAO,cAAA,CAAAC,YAAAC,cAAA,IAAAC,EAAAR,EAAAS,GAAA,OAAAC,KAAAJ,SAAAK,IAAAD,KAAAJ,SAAAK,GAAAC,SAAAF,KAAAG,aAAAH,KAAAG,YAAAL,GAAAE,KAAAJ,SAAAK,GAAAH,CAAA,EAAAM,YAAAd,4DAAA,EAAAe,aAAAf,6DAAA,GAiBA,IAAAgB,EAAAlB,EAAAkB,WAAAC,UAAA,CAGAC,sBAIAf,EAAAF,GAAAE,EAGAgB,QAAAH,EAAAI,WAAA,e,snBCUAC,sCAGAF,EAAAG,YAUAN,mEACA,cAAAG,EAAAI,MAAAC,WAGAC,eACAC,MAAAC,GAEAjB,KAAAkB,OAAAzB,EAAA,SACAO,KAAAkB,OAAAC,KAAA,gBACAnB,KAAAkB,OAAAE,IAAA,CACAC,aACAC,qBAIAtB,KAAAuB,IAAA,KACA,CAGAC,OAIAxB,KAAAyB,IAAA,YAAApB,QAAAL,KAAAkB,QACAlB,KAAAiB,KAQA,MAAAS,OACAA,UAAAC,QACAC,SAAAC,GAPA7B,KAQA8B,IAGAD,gBAXA7B,KAeA+B,+CAAAC,SAAAC,QAAAC,IAAA,IAGAR,gDACAf,2BAIA,IAGAwB,yCAAAH,SAAAC,QAAAC,IAAA,IAGAC,4CAAAH,SAAAC,QAAAC,IAAA,IAOAP,wDAAAK,SAAAC,WAAAG,IALA,IAAAC,IAMAC,YACAF,IAAAG,EAEA,EARAC,4BAWAJ,GAIA,GAGA,CAMAK,YACA9B,oDACAX,KAAA0C,YACA,CAEAC,kBACAhC,6CACA,CAEAiC,cACAjC,sCAGAX,KAAAwB,MACA,G"}