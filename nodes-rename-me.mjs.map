{"version":3,"sources":["_init.js","FeatureName/Template.js"],"names":["window","module","_class","exports","globalThis","Object","defineProperty","value","Blackprint","loadScope","url","import","meta","hasInterface","hasDocs","Context","createContext","EventSlot","slot","registerNode","Node","constructor","instance","super","iface","this","setInterface","title","description","init","update","cable","imported","data","request","syncIn","eventName","input","PortName1","Port","Default","Number","output","PortName2","registerInterface","IFace","MyTemplate","Interface","node","myData","_log","_iface","_value","val","syncOut","assign","IInput","IOutput","Input","Output","ref","log"],"mappings":";;CAAA,eAAAA,EAAAC,GAAA,aAAA,IAAAC,EAAAD,EAAAE,SAAAF,EAAAE,UAAAC,YAAAC,OAAAC,eAAAL,EAAAE,QAAA,aAAA,CAAAI,OAAA,IAOA,IAAAC,EAAAR,EAAAQ,WAAAC,UAAA,CAGAC,IAAAC,OAAAC,KAAAF,IAGAG,cAAA,EAGAC,SAAA,IA6BAC,EAAAP,EAAAQ,cAAA,eAIAD,EAAAE,UAAA,CAAAC,KAAA,yBC5CAV,EAAAW,aAAA,qCAAAjB,EACA,cAAAM,EAAAY,KAeAC,YAAAC,GACAC,MAAAD,GAKA,IAAAE,EAAAC,KAAAC,aAAA,yCACAF,EAAAG,MAAA,WACAH,EAAAI,YAAA,gBACA,CAIAC,OACA,CAKAC,OAAAC,GAEA,CAGAC,SAAAC,GAEA,CAGAC,QAAAH,GAEA,CAIAI,OAAAC,EAAA7B,GACA,eAAA6B,IACAX,KAAAD,MAAAS,KAAA1B,MAAAA,EACA,IAhDA8B,MAAA,CACAC,UAAA9B,EAAA+B,KAAAC,QAAAC,OAAA,MACAvC,EAIAwC,OAAA,CACAC,UAAAF,QACAvC,IA8CAM,EAAAoC,kBAAA,wCACA7B,EAAA8B,MAAAC,WAAA,cAAAtC,EAAAuC,UAGA1B,YAAA2B,GACAzB,MAAAyB,GAEAvB,KAAAwB,OAAA,IACAxB,KAAAyB,KAAA,MAIAzB,KAAAQ,KAAA,CACAkB,OAAA1B,KACAlB,YAAA,OAAAkB,KAAA2B,MAAA,EACA7C,UAAA8C,GACA5B,KAAA2B,OAAAC,EAIA5B,KAAA0B,OAAAH,KAAAM,QAAA,aAAAD,EACA,EAKA,CAGArB,SAAAC,GAEA5B,OAAAkD,OAAA9B,KAAAQ,KAAAA,EACA,CAEAJ,OAIA,MAAA2B,OACAA,EAAAC,QAAAA,EAAAC,MACAA,EAAAC,OAAAA,GACAlC,KAAAmC,GAcA,CAGAC,UAAA,OAAApC,KAAAyB,IAAA,CACAW,QAAAR,GACA5B,KAAAyB,KAAAG,CACA,GACA,CD/HA,CC+HA,oBAAAjD,WAAAA,WAAA,oBAAAJ,OAAAA,OAAAyB,KAAA,oBAAAxB,OAAAA,OAAA,CAAAE,QAAAsB","file":"nodes-rename-me.mjs","sourcesContent":["// This script will run first, and then the other files\n// depends on blackprint.config.js configuration\n\n//> Required, this should be run before importing modules\n//> Blackprint will know if it need to load other interface module\n// Let the Blackprint Editor know the source URL where\n// the registerNode and registerInterface belongs to\nlet Blackprint = window.Blackprint.loadScope({\n\t// You can find the URL on Blackprint menu -> Modules\n\t// This will also be exported to JSON if this module's nodes is being used\n\turl: import.meta.url,\n\n\t// This will autoload (*.sf.mjs) and (*.sf.css) file for Browser\n\thasInterface: true,\n\n\t// This will autoload (*.docs.json) for Browser\n\thasDocs: true,\n});\n\n// Prepare stuff when the page is loading\n// maybe like loading our dependencies for the nodes\n\n\n// Dependency should be loaded after Blackprint.loadScope\n/* Parallely load dependencies from CDN here (optional) */\n//>> imports(...) =>  sf.loader.mjs(...) or [import(..), ..];\n\n// This is just an example, remove if not needed\n// var [ SFMediaStream ] = await imports([\n// \t\"https://cdn.jsdelivr.net/npm/sfmediastream@latest\"\n// ]);\n\n\n/* or wait until the browser was loaded all script and the DOM was ready\n * without load another dependency\n *\n * Warning: When using this, you must modify wrapped:'mjs' to wrapped:'async-mjs'\n * on blackprint.config.js, to avoid circular waiting (because this module also waiting)\n *\n * Info: imports.task() == sf.loader.task;\n */\n// await imports.task();\n\n\n// Global shared context (share to _init.sf)\nlet Context = Blackprint.createContext('LibraryName');\n\n// This is needed to avoid duplicated event listener when using hot reload\n// Event listener that registered with same slot will be replaced\nContext.EventSlot = {slot: 'my-private-event-slot'};","// BPIC/LibraryName is prefix from blackprint.config.js\n// This file is just reference, you can remove unnecessary property/function\n\n// Node will be initialized first by Blackprint Engine\n// This should be used for initialize port structure and set the target interface\nBlackprint.registerNode('LibraryName/FeatureName/Template',\nclass MyTemplate extends Blackprint.Node {\n\t// this == node\n\n\t// You can use type data like Number/String or \"Blackprint.Port\"\n\t// use \"Blackprint.Port.Trigger\" if it's callable port\n\tstatic input = {\n\t\tPortName1: Blackprint.Port.Default(Number, 123)\n\t};\n\n\t// Output only accept 1 type data\n\t// use \"Function\" if it's callable port\n\tstatic output = {\n\t\tPortName2: Number\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\t// Interface path\n\t\t// Let it empty if you want to use default built-in interface\n\t\t// You don't need to '.registerInterface()' if using default interface\n\t\tlet iface = this.setInterface('BPIC/LibraryName/FeatureName/Template');\n\t\tiface.title = 'My Title';\n\t\tiface.description = 'My Description';\n\t}\n\n\t// Put logic as minimum as you can in .registerNode\n\t// You can also put these function on .registerInterface instead\n\tinit(){\n\t\t// Called before iface.init()\n\t}\n\n\t// This is more recomended than using event listener \"port.value\" or \"value\"\n\t// If you want to trigger this manually, you may also need to trigger route out `this.routes.routeOut();`\n\tupdate(cable){\n\t\t// Triggered when any output value from other node are updated\n\t\t// And this node's input connected to that output\n\t}\n\n\timported(data){\n\t\t// When this node was successfully imported\n\t\t// iface can also has this function feature, please use one only\n\t}\n\n\trequest(cable){\n\t\t// Triggered when other connected node is requesting\n\t\t// output from this node that have empty output\n\t}\n\n\t// Add support for remote sync (this will receive data from .syncOut)\n\tsyncIn(eventName, value){\n\t\tif(eventName === 'data.value')\n\t\t\tthis.iface.data.value = value;\n\t}\n});\n\n// For Non-sketch interface\n// - first parameter is named path must use BPIC prefix\n// - second parameter is interface class, should be saved to Context.IFace if you want to access it on '.sf' files, because '.sf' is executed on different context\nBlackprint.registerInterface('BPIC/LibraryName/FeatureName/Template',\nContext.IFace.MyTemplate = class IMyTemplate extends Blackprint.Interface {\n\t// this == iface\n\n\tconstructor(node){\n\t\tsuper(node); // 'node' object from .registerNode\n\n\t\tthis.myData = 123;\n\t\tthis._log = '...';\n\n\t\t// If the data was stored on this, they will be exported as JSON\n\t\t// (Property name with _ or $ will be ignored)\n\t\tthis.data = {\n\t\t\t_iface: this,\n\t\t\tget value(){ return this._value },\n\t\t\tset value(val){\n\t\t\t\tthis._value = val;\n\n\t\t\t\t// Add support for remote sync: .syncOut(eventName, value);\n\t\t\t\t// The data will be received in: syncIn(event, value);\n\t\t\t\tthis._iface.node.syncOut('data.value', val);\n\t\t\t},\n\t\t};\n\n\t\t// Creating object data with class is more recommended\n\t\t// this.data = new MyDataStructure(this);\n\t}\n\n\t// When importing nodes from JSON, this function will be called\n\timported(data){\n\t\t// Use object assign to avoid replacing the object reference (that makes our getter/setter gone)\n\t\tObject.assign(this.data, data);\n\t}\n\n\tinit(){\n\t\t// When Engine initializing this scope\n\n\t\t// ====== Port Shortcut ======\n\t\tconst {\n\t\t\tIInput, IOutput, // Port interface\n\t\t\tInput, Output, // Port value\n\t\t} = this.ref;\n\n\t\t// Port interface can be used for registering event listener\n\t\t// Port value can be used for get/set the port value\n\n\t\t// this.output === IOutput\n\t\t// this.input === IInput\n\t\t// this.node.output === Output\n\t\t// this.node.input === Input\n\n\t\t// this.output.Test => Port Interface\n\t\t// this.node.output.Test => Number value\n\n\t\t// For some event listener please see on ./Template.sf\n\t}\n\n\t// Create custom getter and setter\n\tget log(){ return this._log }\n\tset log(val){\n\t\tthis._log = val\n\t}\n});"]}